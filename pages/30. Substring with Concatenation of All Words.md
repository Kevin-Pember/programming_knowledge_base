- #[[Sliding Window]] #Hashmap #String
- Goal
	- Given a string (s) and an array (words) return an array of all the starts of permutations of the words in the words array
	- Example:
		- ``s = "barfoothefoobarman", words = ["foo", "bar"]``
		- ``output = [0, 9]``
- Thinking Behind the Algorithm
	- Since we know we are using a sliding window lets, think about the specifications of our window. Our window is looking for a substring of our [[String]] which contains all the words in of words [[Array]], all of which have the same length, meaning that our window has a given length based upon the number of words we have and the given length of all of those words. Given that all the words have the same length (in our function word_length) we can also iterate along the string with word_length sized steps. But using this logic we encounter a problem, while the words in the words [[Array]] may be the same length words that randomly occur within the string may not be the same length meaning that our window may contain extraneous data which is included in our word_length steps. To fix this we can have an offset variable which traverses the word length so that misalignment isn't a problem with our window
	- Now that we understand the most difficult part of the problem lets ask another question. How are we going to keep track of the number of words we have seen an make sure that we have seen one word to may times for our window to be a valid permutation. Well a [[Hashmap]] will work, we are going to need two one for the of each word in the words [[Array]] and one for the word count in our window. That way we can check these values against each other to find when we need to shrink the array.
	- Lets go line by line in our implementation (Written based upon the [[Python Implementation]] )
		- word_count
		  id:: 68d2e317-50c1-4b3f-99a9-f871be7e0120
			- The first variable we initialize is our which is the number of words we have in our array. We will then use this value to first find whether there can be any permutations in s, then we will use it to traverse the words array to make our original_count, and finally we will use it to ensure our window has enough words into to be a permutation.
		- n
			- n keeps the length of our string to ensure that we have any permutations and to keep our loops in range
		- indices
			- our return array where we put the strating indexes of each permutation
		- ``if word_count == 0 or n == 0``
			- ensures that cases in which there can be no permutations just immediately return an empty array
		- word_length
			- this keeps track of the shared length of all the words in the words [[Array]]. We will use it to minimize our offset loop
- Implementation
	- [[Python Implementation]] #card
		- id:: 68d2db4b-8f6e-463a-8fb6-3f34e3a1aa60
		  ```
		  class Solution(object):
		      def findSubstring(self, s, words):
		          """
		          :type s: str
		          :type words: List[str]
		          :rtype: List[int]
		          """
		          word_count = len(words)
		          n = len(s)
		          indices = []
		          if word_count == 0 or n == 0: 
		              return indices
		          word_length = len(words[0])
		          
		          original_count = defaultdict(int)
		          for i in range(word_count):
		              original_count[words[i]] += 1
		          for offset in range(word_length):
		              current_count = defaultdict(int)
		              start = offset
		              count = 0
		              end = offset
		              for end in range(offset, n - word_length + 1, word_length):
		                  curr_word = s[end: end + word_length]
		                  if curr_word in original_count:
		                      current_count[curr_word] += 1
		                      count += 1
		                      while current_count[curr_word] > original_count[curr_word]:
		                          start_word = s[start: start + word_length]
		                          current_count[start_word] -= 1
		                          start += word_length
		                          count -= 1
		                      
		                      if count == word_count:
		                          indices.append(start)
		                  else:
		                      count = 0
		                      start = end + word_length
		                      current_count = defaultdict(int)
		          return indices
		  
		  ```
- Image to Remember
	- TODO Create image to remember