- #[[Sliding Window]] #Hashmap #String
- Goal
	- Given a string (s) and an array (words) return an array of all the starts of permutations of the words in the words array
	- Example:
		- ``s = "barfoothefoobarman", words = ["foo", "bar"]``
		- ``output = [0, 9]``
- Thinking Behind the Algorithm
	- Since we know we are using a sliding window lets, think about the specifications of our window. Our window is looking for a substring of our [[String]] which contains all the words in of words [[Array]], all of which have the same length, meaning that our window has a given length based upon the number of words we have and the given length of all of those words. Given that all the words have the same length (in our function word_length) we can also iterate along the string with word_length sized steps. But using this logic we encounter a problem, while the words in the words [[Array]] may be the same length words that randomly occur within the string may not be the same length meaning that our window may contain extraneous data which is included in our word_length steps. To fix this we can have an offset variable which traverses the word length so that misalignment isn't a problem with our window
	- Now that we understand the most difficult part of the problem lets ask another question. How are we going to keep track of the number of words we have seen an make sure that we have seen one word to may times for our window to be a valid permutation. Well a [[Hashmap]] will work, we are going to need two one for the of each word in the words [[Array]] and one for the word count in our window. That way we can check these values against each other to find when we need to shrink the array.
	- Lets go line by line in our implementation (Written based upon the [[Python Implementation]] )
		- word_count
		  id:: 68d2e317-50c1-4b3f-99a9-f871be7e0120
			- The first variable we initialize is our which is the number of words we have in our array. We will then use this value to first find whether there can be any permutations in s, then we will use it to traverse the words array to make our original_count, and finally we will use it to ensure our window has enough words into to be a permutation.
		- n
			- n keeps the length of our string to ensure that we have any permutations and to keep our loops in range
		- indices
			- our return array where we put the strating indexes of each permutation
		- ``if word_count == 0 or n == 0``
			- ensures that cases in which there can be no permutations just immediately return an empty array
		- word_length
			- this keeps track of the shared length of all the words in the words [[Array]]. We will use it to minimize our offset loop meaning that we don't run more loops then we have to, we will also use the value to ensure that in our loops index outside the range, to find the current word, and to advance start to the next word in the [[String]] .
		- oringinal_count
			- this is one of our two [[Hashmap]]s that keep track of amount of times words occur. This one keeps track of the occurrence of words in the words array, which is what the following loop assigns
		- ``for offset in range(word_length)``
			- This loop is how we manage our offset. Since start is defined off the offset value it determines a offset from 0 to word_length to shift our window so that it isn't misaligned with possible permutations
		- Misalignment
			- When we are talking about misalignment we mean the following exmaple
			- Examples
				- Example 1 (Under word_length)
					- our s is ``"xfoobarbar"``
					- words = ``["bar",  "bar", "foo"]``
					- The issue is if we start at 0 for our word traversal our words would end up being "xfo", "oba", "rba", "r" none of which from a permutation which is what an offset of 1 would fix
				- Example 2 (Over word_length)
					- our s is ``"xeseefoobarbar"``
					- words = ``["bar",  "bar", "foo"]``
					- The goal here is to show that we only need an offset between 0 to word_length - 1. Since ``"see"`` can be considered a word in and of itself we only need an offset of 2 to align our window. This stays the same with any offset because alignment needs to only be on a word_length structure
		- current_count
			- This is our second hashmap to keep track of the word counts in our window
		- so now that we have more of an understanding what the variables are for we want the start of our window to be at offset we then expand the window if the last word was in the word set and not in the current set or create a new window at the start of the next word. We then add start to the list of indices if count get to the word count
- Implementation
	- [[Python Implementation]] #card
		- id:: 68d2db4b-8f6e-463a-8fb6-3f34e3a1aa60
		  ```
		  class Solution(object):
		      def findSubstring(self, s, words):
		          """
		          :type s: str
		          :type words: List[str]
		          :rtype: List[int]
		          """
		          word_count = len(words)
		          n = len(s)
		          indices = []
		          if word_count == 0 or n == 0: 
		              return indices
		          word_length = len(words[0])
		          
		          original_count = defaultdict(int)
		          for i in range(word_count):
		              original_count[words[i]] += 1
		          for offset in range(word_length):
		              current_count = defaultdict(int)
		              start = offset
		              count = 0
		              end = offset
		              for end in range(offset, n - word_length + 1, word_length):
		                  curr_word = s[end: end + word_length]
		                  if curr_word in original_count:
		                      current_count[curr_word] += 1
		                      count += 1
		                      while current_count[curr_word] > original_count[curr_word]:
		                          start_word = s[start: start + word_length]
		                          current_count[start_word] -= 1
		                          start += word_length
		                          count -= 1
		                      
		                      if count == word_count:
		                          indices.append(start)
		                  else:
		                      count = 0
		                      start = end + word_length
		                      current_count = defaultdict(int)
		          return indices
		  
		  ```
- Image to Remember
	- TODO Create image to remember